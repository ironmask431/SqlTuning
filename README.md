# SqlTuning
업무에 바로 쓰는 SQL튜닝

* 1장. Mysql 과 MariaDB 개요   
* 2장. sql 튜닝 용어를 직관적으로 이해하기   
* 3장. sql 튜닝의 실행계획 파헤치기   
* 4장. 악성 sql 튜닝으로 초보자 탈출하기   
* 5장. 악성 sql 튜닝으로 전문가 되기   

### 1장. Mysql 과 MariaDB 개요 

* Mysql은 1995년 오픈소스로 배포된 무료 DBMS
* 2010년 오라클에 인수되었고 2018.05에 배포된 8.0 버전이 현재 최신 버전이다. (2023.08 기준)
* MYSQL이 오라클에 인수되고, MYSQL 핵심개발자 주도로 오픈소스(무료)정책을 지향하는 MariaDB가 탄생함.
* Mysql, MariaDB간 차이는 거의없다. MariaDB 는 현재 11.0 버전까진 나옴.

**1. 현황**   
1. 부각배경 - Mysql은 상용버전(오라클)과 무료버전 2가지가 있음. mariaDB는 완전한 오픈소스 소프트웨어 
2. DB엔진 영향력 - 오픈소스RDBMS의 영향력. mysql이 58%, Postgre 27%, MariaDB 5%
3. mysql 과 mariaDB가 63%에 육박하는 높은 점유율을 가지고 있음.

**2. 상용 RDBMS(오라클)와 차이점**
1. 구조적차이
   - 오라클은 서버이중화 시 각각의 DB서버가 하나의 스토리지를 공유한다.
   - MYSQL은 서버이중화 시 각각의 DB서버가 각각의 스토리지를 사용한다.
   - MYSQL은 이중화 시 주로 마스터(주)-슬레이브(종)구조를 사용한다.
   - 마스터노드는 쓰기,읽기 모두 가능. 슬레이브 노드는 읽기만 가능하다.
   - 마스터노드, 슬레이드노드간 동기화 시간차이가 발생하는 경우 조회 시 결과가 다르게 나올 수 있다.
 
   ```
   * 쿼리 오프로딩
   
   - DB서버의 트랜잭션에서 쓰기와 읽기를 각각분리하여 DB 처리량을 늘리는 성능향상 기법
   - 쓰기 트랜잭션 : UPDATE, INSERT, DELETE
   - 읽기 트랜잭션 : SELECT 
   ```
2. MYSQL과 오라클의 지원 기능의 차이
   - 오라클과 MYSQL은 제공하는 조인알고리즘 기능에 차이가 있다.
   - MYSQL 은 대부분 중첩루프조인 방식을 제공
   - 오라클은 그외에 정렬병합조인, 해시조인 방식도 제공한다.
   - (오라클의 조인성능이 더 뛰어나다고 볼 수 있다.)
   - MYSQL은 오라클과 달리 데이터를 저장하는 스토리지 엔진개념을 포함하므로
   - 오픈소스 DBMS를 바로 꽂아서 사용할 수 있는 확장성이 특징이다(?)
   - MYSQL은 오라클 대비 메모리 사용률이 상대적으로 낮아서 비교적 낮은 사양에서도 가능하다.
   - MYSQL은 1MB 메모리 환경에서도 가능하나, 오라클은 최소 수백MB의 환경이 제공되어야 설치가능.

3. MYSQL과 오라클L의 SQL구문의 차이
   - INNULL / NVL
   - LIMIT 5 / ROWNUM <= 5
   - NOW() / SYSDATE
   - IF / DECODE
   - DATE_FORMAT, TO_CHAR
   - SUBSTRING / SUBSTR 등
   - mysql : auto_increment 있다. / 오라클 : 없어서 시퀀스만들어써야함.  
  
4. Mysql SWOT 분석
   - S : 오픈소스(무료), 경량
   - W : 조인알고리즘 부족
   - O : 스토리지 엔진 확장성
   - T : Mysql 라이선스 정책 (오라클에 인수되었으므로 유료화가능성) / MARIADB는 괜찮 ^^
  
### 2장. SQL 튜닝용어를 직관적으로 이해하기

**1. 물리엔진과 오브젝트 용어**
1. DB엔진 용어
   - 스토리지 엔진 (innoDB, MyISAM, MEMORY등) : 디스크나 메모리에서 데이터를 가져오는 역할.
   - innoDB엔진을 주로 사용함. 대량의 쓰기 트랜잭션이 발생하면 MyISAM엔진, 메모리 데이터를 빠르게 읽으려면 MEMORY 엔진을 사용하는 식으로 응용가능.
   - MySQL 엔진 : SQL문의 시작 및 마무리단계에 관여함. sql구문 검사. 스토리지 엔진으로부터 받은 데이터의 불필요 제거, 가공및 연산 담당

2. SQL프로세스 용어
   1. parser 파서
      - MySQL엔진에 포함. SQL문을 쪼개 분리하며 문법검사를 수행.
   2. 전처리기
      - MySQL엔진에 포함. SQL문에 구조적인 문제가없는지 판단.
   3. optimizer 옵티마이저
      - 옵티마이저는 mysql의 핵심엔진중 하나로 DBMS의 두뇌.
      - 어떤순서로 테이블접근할지, 인덱스 사용여부, 어떤인덱스를 사용할지, 임시테이블을 사용할지 등 전략 수립
      - 실행계획으로 도출할수 있는 경우의 수가 너무 많을때는 시간이 오래걸리므로, 모든 실행계획을 다 판단하지는 않음.
      - 즉 옵티마이저가 선택한 전략이 최상이 실행계획은 아닐 수 도 있음.
   4.  엔진 실행기
      - 옵티마이저에서 수립한 실행 계획을 참고하여 스토리지 엔진으로 부터 데이터를 가져옴.
      - 이후 읽어온 데이터를 정렬, 조인, 필터링등을 진행. MySql엔진의 부하를 줄이려면 스토리지 엔진에서 가져오는 데이터량을 줄이는게 매우 중요함.

3. DB오브젝트 용어
   1. 테이블
   2. 로우(행)
   3. 기본키
      - 기본키(PK)는 특정행을 대표하는 열. 기본키는 인덱스 역할도 하므로, 기본키를 활용해 인덱싱도 가능.
      - mysql에서 기본키는 클러스터형 인덱스로 작동한다. 기본키의 구성열 순서를 기준으로 물리적인 스토리지에 데이터가 쌓이므로
      - 비슷한 기본 키값들은 근거리에 저장된다. 기본키를 활용하여 인덱스 스캔을 수행하면 테이블 데이터에 더 빠르게 접근 할 수 있다.
        
        ```
        * 기본키 인덱스 주의사항.
   
        기본키와 똑같은 인덱스를 생성하면 인덱스가 저장되는 물리적 공간 낭비와
        인덱스 정렬의 오버헤드가 발생함.기본적으로 PK 순으로 정렬되어 있기 때문에
        PK로는 인덱스를 만들 필요가없다.
        ```
   4. 인덱스
      - 모든 데이터를 처음부터 끝까지 전부 차례로 검색하는 비효율적인 방식을 개선하기위해 인덱스가 필요.
      - 책의 목차와 비슷하다고 볼 수 있음. 인덱스를 사용하면 원하는 페이지를 빠르게 찾을 수 있다.
      - 특정 컬럼을 인덱스로 지정하면, 해당 컬럼의 데이터 기준으로 정렬된 인덱스가 별도로 생성된다. (정렬된 데이터 - pk번호)
      - 인덱스는 추가로 메모리를 할당하여 생성되고, 인덱스컬럼이 입력, 수정, 삭제가 될때마다 인덱스도 재정렬을 해야하므로
      - 인덱스를 무분별하게 남발하면 자원낭비가 발생할 수 있다. 
  
        ```
        * 인덱스의 예시.
   
        1. 학생테이블에서 "학번"이 PK 이고 "이름" 컬럼에 인덱스를 부여한 경우.
        2. 학생테이블의 실제 데이터는 "학번" (PK) 순으로 쌓임. 
        3. 학생 테이블의 "이름" 인덱스는 이름 컬럼 기준으로 정렬되어 생성된다..
   
        학생 테이블 (파일이 쌓이는 순서 = 학번(pk) 순으로 쌓임.)
        ----------------------
        학번(PK) 이름
        ----------------------
        10001 홍길동
        10002 나관중
        10003 이순신
        ...
        
        10999 라마다
   
        이름 인덱스 (이름순으로 나열되어있고 해당 학생의위치(학번) 정보를 가지고 있음)
        ----------------------
        이름     학번(PK)
        ----------------------
        강감찬   23129 
        나관중   10002
        라마다   10999
        이순신   10003
        ...
        홍길동   10001
   
        * 이름으로 검색 시 이름순으로 정렬된 인덱스를 활용하여 위치(학번)을 빠르게 확인 가능
        ```

   5. 고유 인덱스와 비고유 인덱스
      - 고유인덱스(UNIQUE_INDEX) : 말그대로 인덱스를 구성하는 열들의 데이터가 유니크함. (중복불가)
      - 기본키(PK)와 고유인덱스의 차이 : 특성과 목적이 비슷하지만, 고유인덱스는 null이 가능한것이 차이점.
      - 비고유 인덱스 : 중복을 허용하는 인덱스

        ```
        * 고유 인덱스 생성 쿼리
        ALTER TABLE 학생 ADD UNIQUE INDEX 연락처_인덱스(연락처);
   
        * 인덱스 생성 쿼리
        ALTER TABLE 학생 ADD INDEX 이름_인덱스(이름);
        ```

   6. 뷰
      - 뷰는 가상의 테이블
      - 학생테이블을 바라보는 학생뷰를 생성 할 경우 뷰에서는 여러 컬럼중 학번과 이름만 노출 시킬 수 있다. 
      - 뷰를 사용하는 이유 : 테이블에서 일부 데이터만 공개하고 노출에 민감한 데이터는 제약을 설정할 수 있는 보안성 때문.
      - 또한 여러개의 테이블을 병합(JOIN)한 성능고려 최적화된 뷰를 생성하여 사용할 경우 일관된 성능을 제공가능.

        ```
        * 뷰 생성 쿼리
        CREATE VIEW 학생_뷰 AS
        SELECT 학번,이름
        FROM 학생;
        ```
**2. 논리적인 SQL 개념 용어**

   1. 서브쿼리 위치에 따른 SQL 용어

      1. 스칼라 서브쿼리 : select 절에서 사용되는 서브쿼리
      2. 인라인 뷰 : FROM 절에서 사용되는 서브쿼리. 내부적으로 메모리 또는 디스크에 임시테이블 생성하여 구현됨
      3. 중첩 서브쿼리 : WHERE절에서 사용되는 서브쿼리

         ```
            select (select ... from ...)  -> 스칼라 서브쿼리 
            from (select ... from ...) -> 인라인뷰
            where 컬럼명 in (select ... from ...) -> 중첩 서브쿼리
         ```

   2. 메인쿼리와의 관계성에 따른 SQL 용어

      1. 비상관 서브쿼리 : 메인쿼리와 서브쿼리 관계성없음.  서브쿼리 -> 메인쿼리 순으로 실행됨.
         ```
         SELECT FROM 학생 -> 메인쿼리
         WHERE ... IN (SELECT ... FROM 지도교수) -> 서브쿼리
         ```

      2. 상관 서브쿼리 : 메인쿼리와 서브쿼리 관계성 있음.
         ```
         SELECT FROM 학생
         WHERE ... IN (SELECT ... FROM 지도교수 WHERE 학생.학번 = ....)
         ```
         실행순서 : 메인쿼리(학생.학번 가져옴) -> 서브쿼리 -> 메인쿼리

   5. 조인 알고리즘 용어

      1. 드라이빙 테이블과 드리븐 테이블

         ```
         SELECT 학생.학번, 학생.이름,비상연락망.관계, 비상연락망.연락처
         FROM 학생
         JOIN 비상연락망 ON 학생.학번 = 비상연락망.학번
         WHERE 학생.학번 IN (1,100);
         ```

         - 위 쿼리에서는 학생.학번 IN 조건이 있으므로 학생테이블의 데이터를 먼저 찾음.
         - 그다음 비상연락망 테이블을 조회.
         - 두개의 테이블에 동시접근 할 수 없으므로 먼저 접근하는 테이블은 학생은 "드라이빙 테이블"
         - 그다음 접근하는 테이블을 "드리븐 테이블" 이라고함.
         - 드라이빙 테이블에서 많은 건수가 반환되면 해당결과를 가지고 드리븐 테이블에 접근하므로
         - 드라이빙 테이블을 무엇으로 선정할지가 중요한 문제이다.
         - 가능한 적은결과가 반환될것으로 예상되는 드라이빙 테이블을 선정하고, 조인조건절의 열이
         - 인덱스로 설정되도록 구성해야 한다.

      2. 중첩 루프 조인
         - 드라이빙 테이블 1건당 드리븐테이블을 스캔 검색하며 조회
         - 드라이빙 테이블과 드리븐 테이블의 조인컬럼에 인덱스여부에 따라 속도차이 발생가능.
         - 비고유 인덱스일 경우 임의 접근 방식인 랜덤 액세스가 발생 함.
         - 기본키(클러스터형 인덱스)는 기본키의 순서대로 테이블이 적재되어 있으므로 조회효율이 아주 좋음.
        
      3. 해시 조인
         - 해시조인은 MYSQL 8  버전부터 지원되는 조인방식
         - 기존 중첩루프조인의 발전형
         - 해시값으로 내부조인을 수행결과를 조인버퍼에 저장.. 조인열의 인덱스를 필수요구하지않음? 암튼 좋다..
        
**3. 개념적인 튜닝 용어**

   1. 기초용어

      1. 오브젝트 스캔 유형

         - **테이블 풀 스캔**
           ```
           인덱스를 거치지 않고 테이블을 처음부터 끝까지 스캔
           조회조건에 인덱스가 없거나 전체 데이터대비 대량의 데이터를 조회할 시
           성능측면에서 부정적. 인덱스없이 사용하는 유일한 방식
           ```   
        
         - **인덱스 범위 스캔**
            ```
           인덱스를 범위기준으로 스캔한 뒤 데이터찾음.
           BETWEEN ~ AND, < , > , LIKE 구문연산시 사용
           좁은 범위를 조회시에는 매우 효율적이나, 넓은 범위조회시에는 비효율적
            ```
        
         - **인덱스 풀 스캔**
           ```
           인덱스를 처음부터 끝까지 스캔.
           테이블에 접근하지 않고 인덱스의 데이터만 조회해도 되는경우.
           테이블 풀스캔 보단 낫지만.. 좋진않다.
           ```
        
         - **인덱스 고유 스캔**
           ```
           기본키나 고유 인덱스로 검색. 인덱스 스캔방법중 가장 효율적인 방법.
           "WHERE 컬럼 = 조건" 에서 해당 조인열(컬럼)이 기본키 또는 고유 인덱스일 경우
           ```
        
         - **인덱스 루스 스캔**
           ```
           인덱스의 필요한 부분들만 골라 스캔
           GROUP BY 나 MAX(), MIN() 에서 사용됨.
           ```
        
         - **인덱스 병합 스캔**
           ```
           인덱스들을 통합하여 스캔.
           WHERE 조건절들이 서로 다른 인덱스로 존재하면, 옵티마이저가 2개이상의 인덱스를 모두 가져와서 활용
           병합 스캑은 물리적으로 따로 존재하는 개별인덱스에 접근해야 하므로 효율이 좋지않음.
           별개로 생성된 인덱스들을 하나로 통합하거나 SQL문 자체를 하나의 인덱스만 사용하도록 변경할 수 있음.
           ```
   2. 응용 용어
      1. 선택도
         - 해당 열의 조건절에 따라 선택되는 데이터의 양
         - 해당 열에 중복되는 데이터가 많다면 선택도가 "높다" 라고 볼수 있다.
         - 반대로 중복되는 데이터가 적다면 선택도가 "낮다" 라고 한다.
         - 선택도가 "낮은" 열은 인덱스 생성 고려대상이 된다.
           
           ```
            선택도 = 선택한 데이터 건수 / 전체 대이터 건수 (모두 중복이면 1이 됨. 선택도가 가장높다.)
           ```

      2. 카디널리티
         - 선택도와 상반되는 개념
         - 특정 열에 중복값이 많다면 카디널리티가 "낮다"
         - 특정열에 중복값이 적다면 카디널리티가 "높다"
           ```
           카디널리티 = 전체 데이터 건수 X 선택도 
           ```

           ```
           * 카디널리티 예시

            1. 주민등록번호 : 카디널리티 매우 높음 (중복 없음)
            2. 이름 : 카디널리티 보통 (일부 중복)
            3. 성별 : 카디널리티 낮음 (많이 중복)
           ```

      3. 힌트

         - 옵티마이저에 특정 인덱스 사용 힌트를 줄 수 있다.

           ```
           * 힌트 사용 방법
           SELECT 학번, 전공코드
           FROM 학생 /*! USE INDEX (학생_IDX01) */
           WHERE 이름 = '유재석';

           * 주석을 생락하는것도 가능하다. 
           SELECT 학번, 전공코드
           FROM 학생 USE INDEX (학생_IDX01)
           WHERE 이름 = '유재석';

           * 주요 힌트 목록
           - STRAIGHT_JOIN : FROM절에 작성된 테이블 순으로 조인을 유도 (활용도 : 높음)
           - USE INDEX : 특정 인덱스 사용하도록 유도  (활용도 : 높음)
           - FORCE INDEX : 특정 인덱스 강하게 유도  (활용도 : 낮음)
           - IGNORE INDEX : 특정 인덱스 사용못하게 유도  (활용도 : 중간)
           ```

         - 옵티마이저가 힌트를 무조건 참고하진 않는다. 비효율적이라 판단되면 미사용함.

      4. 콜레이션

         - 특정 문자셋으로 값일 비교하거나 정렬하는 기준
         - 콜레이션에 따라 정렬순서가 다르다. 
         - utf8_bin : A, B, a, b
         - utf8_general_ci : A, a, B, b
         - 콜레이션은 데이터베이스, 테이블, 열단위 까지 통합또는 세세하게 별개로 설정 가능하다. 
   

### 3장. SQL 튜닝의 실행계획 파헤치기

**2. 실행 계획 수행**

   1. 기본 실행계획 수행
   2. 기본 실행계획 항목 분석

      ```
      * ID
      실행 순서


      * SELECT_TYPE (*성능 판단 기준열)
      (좋음)
      1. simple : 유니온이나 내부쿼리가 없는 단순 select
      2. primary : 서브쿼리또는 유니온이 포함된 sql문이 있을 때 첫번째 select 문에 해당하는 쿼리
      3. subquery : 독립적으로 수행되는 서브쿼리
      4. derived : from절에 작성된 서브쿼리

      (나쁨)
      5. dependent
      6. uncacheable 

      * TABLE
      테이블명


      * TYPE (*성능 판단 기준열)
      (좋음)
      1. system : 테이블에 데이터가 없거나 1개만 있는 경우
      2. const : 드라이빙 테이블에서 고유인덱스나 기본키로 1건의 데이터만 조회되는 경우
      3. eq_ref : 드리븐 테이블에서 고유인덱스, 기본키로  1건의 데이터만 조회되는 경우
      (보통)
      4. ref : 드리븐 테이블에서 2건이상의 데이터가 조회되는 경우 (비고유인덱스, BETWEEN 범위검색)
      5. ref_or_null : ref와 유사, is null 구문에 대해 인덱스 활용
      6. range : 테이블내의 연속된 데이터 범위 조회 < > between,, in ... 범위가 넓어질수록 성능 저하.
      7. index_merge : 두개 이상의 인덱스를 병합하여 사용
      (나쁨)
      8. index : 인덱스를 처음부터 끝까지 풀로
      9. all : 테이블 풀스캔, 인덱스가 없거나, 인덱스를 안쓰는게 더 낫다고 옵티가 판단할 경우.(전체의 약 20%이상 검색)
      인덱스를 추가하거나, 기존인덱스를 변경하여 튜닝.

      * KEY
      사용되는 기본키 또는 인덱스. 비효율적인 인덱스나 인덱스를 사용하지 않았다면 튜닝대상

      * REF
      테이블 조인을 수행할 때 드리븐 테이블에 어떤조건으로 해당 테이블에 엑세스 되었는지 알려줌

      * ROWS
      접근하는 데이터의 row수 예측. 수치가 정확하진 않음.
      디스크에서 데이터를 조회해서 메모리에서 처리해야할 행 수 
      (최종출력될 row수 아님.)
      sql문의 최종결과 건수와 비교해서 차이가 많이날때는 불필요하게 많이 조회했을수 있으므로,
      sql 튜닝대상이 될 수 있다.

      * EXTRA (*성능 판단 기준열)
      추가정보
      (좋음)
      using index
      (나쁨)
      using filesort
      using temporary
     
      ```
 
   
